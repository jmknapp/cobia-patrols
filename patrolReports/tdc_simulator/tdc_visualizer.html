<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TDC Mark III Mechanical Simulator</title>
    <style>
        :root {
            --bg-dark: #1a1a2e;
            --bg-panel: #16213e;
            --brass: #c9a227;
            --brass-light: #e8c547;
            --steel: #4a5568;
            --steel-light: #718096;
            --text: #e2e8f0;
            --text-muted: #a0aec0;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: var(--bg-dark);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, var(--bg-panel), var(--bg-dark));
            padding: 1rem 2rem;
            border-bottom: 2px solid var(--brass);
            text-align: center;
        }
        
        .header h1 {
            color: var(--brass);
            font-size: 1.8rem;
            letter-spacing: 2px;
        }
        
        .header p {
            color: var(--text-muted);
            font-size: 0.9rem;
        }
        
        .main-container {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            gap: 1rem;
            padding: 1rem;
            height: calc(100vh - 80px);
        }
        
        .panel {
            background: var(--bg-panel);
            border: 1px solid var(--steel);
            border-radius: 8px;
            padding: 1rem;
        }
        
        .panel h2 {
            color: var(--brass);
            font-size: 1rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--steel);
        }
        
        .input-group {
            margin-bottom: 1rem;
        }
        
        .input-group label {
            display: block;
            color: var(--text-muted);
            font-size: 0.8rem;
            margin-bottom: 0.3rem;
        }
        
        .input-group input {
            width: 100%;
            padding: 0.5rem;
            background: var(--bg-dark);
            border: 1px solid var(--steel);
            color: var(--brass-light);
            font-family: inherit;
            font-size: 1rem;
            border-radius: 4px;
        }
        
        .input-group input:focus {
            outline: none;
            border-color: var(--brass);
        }
        
        .output-value {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem;
            background: var(--bg-dark);
            border-radius: 4px;
            margin-bottom: 0.5rem;
        }
        
        .output-value .label {
            color: var(--text-muted);
        }
        
        .output-value .value {
            color: var(--brass-light);
            font-weight: bold;
        }
        
        .center-column {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            height: 100%;
            overflow: hidden;
        }
        
        .tactical-view {
            flex: 0 0 280px;
            position: relative;
            height: 280px;
            min-height: 280px;
            max-height: 280px;
        }
        
        #tacticalCanvas {
            width: 100%;
            height: 248px;
            background: radial-gradient(ellipse at center, #0a1628 0%, #050a14 100%);
            border-radius: 8px;
            border: 1px solid var(--steel);
        }
        
        .mechanism-view {
            flex: 1;
            position: relative;
            overflow: hidden;
            min-height: 0; /* Important for flex child to shrink */
        }
        
        #mechanismCanvas {
            width: 100%;
            height: 100%;
            max-height: 100%;
            background: radial-gradient(ellipse at center, #1e293b 0%, var(--bg-dark) 100%);
            border-radius: 8px;
        }
        
        .controls {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        
        .btn {
            flex: 1;
            padding: 0.8rem;
            background: var(--steel);
            border: 1px solid var(--steel-light);
            color: var(--text);
            font-family: inherit;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .btn:hover {
            background: var(--steel-light);
        }
        
        .btn.primary {
            background: var(--brass);
            color: var(--bg-dark);
            border-color: var(--brass-light);
        }
        
        .btn.primary:hover {
            background: var(--brass-light);
        }
        
        .component-legend {
            margin-top: 1rem;
            font-size: 0.75rem;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.3rem;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }
        
        .speed-control {
            margin-top: 1rem;
        }
        
        .speed-control input[type="range"] {
            width: 100%;
        }
        
        .random-btn {
            width: 100%;
            margin-top: 0.5rem;
            background: linear-gradient(135deg, #6366f1, #4f46e5);
            border: 2px solid #818cf8;
            color: white;
            font-weight: bold;
            padding: 0.6rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .random-btn:hover {
            background: linear-gradient(135deg, #818cf8, #6366f1);
            box-shadow: 0 0 15px rgba(99, 102, 241, 0.5);
        }
        
        .fire-btn {
            width: 100%;
            margin-top: 0.5rem;
            background: linear-gradient(135deg, #dc2626, #991b1b);
            border: 2px solid #ef4444;
            color: white;
            font-weight: bold;
            font-size: 1.1rem;
            padding: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .fire-btn:hover {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            box-shadow: 0 0 15px rgba(239, 68, 68, 0.5);
        }
        
        .fire-btn:disabled {
            background: #4a5568;
            border-color: #718096;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .solution-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 12px;
            background: linear-gradient(135deg, #1a1a2e, #0f0f1a);
            border: 2px solid #2d2d44;
            border-radius: 8px;
            margin-bottom: 1rem;
        }
        
        .indicator-light {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #2d2d44;
            border: 2px solid #4a4a6a;
            transition: all 0.3s;
        }
        
        .indicator-light.solving {
            background: radial-gradient(circle at 30% 30%, #fbbf24, #d97706);
            box-shadow: 0 0 15px #f59e0b, 0 0 30px rgba(245, 158, 11, 0.5);
            animation: pulse-amber 0.5s ease-in-out infinite;
        }
        
        .indicator-light.solved {
            background: radial-gradient(circle at 30% 30%, #4ade80, #16a34a);
            box-shadow: 0 0 20px #22c55e, 0 0 40px rgba(34, 197, 94, 0.6);
            animation: none;
        }
        
        @keyframes pulse-amber {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(0.95); }
        }
        
        .indicator-label {
            font-size: 1.1rem;
            font-weight: bold;
            letter-spacing: 2px;
            color: #6b7280;
            transition: color 0.3s;
        }
        
        .indicator-label.solving {
            color: #f59e0b;
        }
        
        .indicator-label.solved {
            color: #22c55e;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>‚öôÔ∏è TDC MARK III MECHANICAL SIMULATOR ‚öôÔ∏è</h1>
        <p>Torpedo Data Computer - Analog Fire Control Computer Visualization</p>
    </div>
    
    <div class="main-container">
        <!-- Input Panel -->
        <div class="panel">
            <h2>üì• INPUTS</h2>
            
            <div class="input-group">
                <label>Own Course (¬∞)</label>
                <input type="number" id="ownCourse" value="281" min="0" max="360">
            </div>
            
            <div class="input-group">
                <label>Own Speed (knots)</label>
                <input type="number" id="ownSpeed" value="3" min="0" max="25">
            </div>
            
            <div class="input-group">
                <label>Target Bearing (¬∞)</label>
                <input type="number" id="targetBearing" value="291" min="0" max="360">
            </div>
            
            <div class="input-group">
                <label>Target Range (yards)</label>
                <input type="number" id="targetRange" value="900" min="100" max="20000">
            </div>
            
            <div class="input-group">
                <label>Target Course (¬∞)</label>
                <input type="number" id="targetCourse" value="115" min="0" max="360">
            </div>
            
            <div class="input-group">
                <label>Target Speed (knots)</label>
                <input type="number" id="targetSpeed" value="8" min="0" max="30">
            </div>
            
            <div class="controls">
                <button class="btn primary" id="startBtn">‚ñ∂ START</button>
                <button class="btn" id="resetBtn">‚Ü∫ RESET</button>
            </div>
            
            <button class="btn random-btn" id="randomBtn">üé≤ RANDOM SCENARIO</button>
            
            <button class="btn fire-btn" id="fireBtn">üî• FIRE TORPEDO</button>
            
            <div class="speed-control">
                <label>Simulation Speed</label>
                <input type="range" id="simSpeed" min="0.1" max="5" step="0.1" value="5">
                <span id="speedLabel">5.0x</span>
            </div>
        </div>
        
        <!-- Center Column: Tactical Map + Mechanism -->
        <div class="center-column">
            <!-- Tactical Map -->
            <div class="panel tactical-view">
                <canvas id="tacticalCanvas"></canvas>
            </div>
            
            <!-- Mechanism Visualization -->
            <div class="panel mechanism-view">
                <canvas id="mechanismCanvas"></canvas>
            </div>
        </div>
        
        <!-- Output Panel -->
        <div class="panel">
            <!-- Solution Indicator -->
            <div class="solution-indicator" id="solutionIndicator">
                <div class="indicator-light" id="solutionLight"></div>
                <span class="indicator-label" id="solutionLabel">STANDBY</span>
            </div>
            
            <h2>üì§ OUTPUTS</h2>
            
            <div class="output-value">
                <span class="label">Gyro Angle</span>
                <span class="value" id="gyroAngle">--¬∞</span>
            </div>
            
            <div class="output-value">
                <span class="label">Rel. Bearing (Br)</span>
                <span class="value" id="relBearing">--¬∞</span>
            </div>
            
            <div class="output-value">
                <span class="label">Target Angle (A)</span>
                <span class="value" id="targetAngle">--¬∞</span>
            </div>
            
            <div class="output-value">
                <span class="label">Track Angle</span>
                <span class="value" id="trackAngle">--¬∞</span>
            </div>
            
            <div class="output-value">
                <span class="label">Torpedo Run</span>
                <span class="value" id="torpedoRun">-- yds</span>
            </div>
            
            <div class="output-value">
                <span class="label">Run Time</span>
                <span class="value" id="runTime">-- sec</span>
            </div>
            
            <h2 style="margin-top: 1.5rem;">üìç POSITION KEEPER</h2>
            
            <div class="output-value">
                <span class="label">Present Bearing (B)</span>
                <span class="value" id="presentBearing">--¬∞</span>
            </div>
            
            <div class="output-value">
                <span class="label">Present Range (R)</span>
                <span class="value" id="presentRange">-- yds</span>
            </div>
            
            <div class="output-value">
                <span class="label">Elapsed Time</span>
                <span class="value" id="elapsedTime">-- sec</span>
            </div>
            
            <h2 style="margin-top: 1.5rem;">üîß COMPONENT LEGEND</h2>
            <div class="component-legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #c9a227;"></div>
                    <span>Differential (Add/Subtract)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #48bb78;"></div>
                    <span>Integrator (Multiply & Sum)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4299e1;"></div>
                    <span>Resolver (Sin/Cos)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ed8936;"></div>
                    <span>Cam (Function)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #9f7aea;"></div>
                    <span>Synchro (Transmit)</span>
                </div>
            </div>
        </div>
    </div>
    
    <script src="/tdc/tdc_engine.js"></script>
    <script>
        // TDC Mark III Mechanical Simulator
        // Now powered by true mechanical simulation engine
        
        const canvas = document.getElementById('mechanismCanvas');
        const ctx = canvas.getContext('2d');
        
        // Initialize the TDC simulation engine
        const tdc = new TDCMarkIII();
        
        // Tactical map canvas
        const tacticalCanvas = document.getElementById('tacticalCanvas');
        const tacticalCtx = tacticalCanvas.getContext('2d');
        
        // Tactical map zoom and pan state
        let tacticalZoom = 1.0;       // Zoom multiplier (1.0 = auto-fit)
        let tacticalPanX = 0;         // Pan offset in world coordinates (yards)
        let tacticalPanY = 0;
        let tacticalDragging = false;
        let tacticalDragStartX = 0;
        let tacticalDragStartY = 0;
        let tacticalPanStartX = 0;
        let tacticalPanStartY = 0;
        
        // Tactical map mouse events
        tacticalCanvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            tacticalZoom = Math.max(0.1, Math.min(50.0, tacticalZoom * zoomFactor));
        });
        
        tacticalCanvas.addEventListener('mousedown', (e) => {
            tacticalDragging = true;
            tacticalDragStartX = e.clientX;
            tacticalDragStartY = e.clientY;
            tacticalPanStartX = tacticalPanX;
            tacticalPanStartY = tacticalPanY;
            tacticalCanvas.style.cursor = 'grabbing';
        });
        
        tacticalCanvas.addEventListener('mousemove', (e) => {
            if (tacticalDragging) {
                // Convert pixel drag to world coordinates
                // Need to know the current scale to convert properly
                const w = tacticalCanvas.width;
                const h = tacticalCanvas.height;
                const baseScale = Math.min(w, h) / 2000 * 0.8; // Approximate base scale
                const scale = baseScale * tacticalZoom;
                
                const dx = (e.clientX - tacticalDragStartX) / scale;
                const dy = (e.clientY - tacticalDragStartY) / scale;
                tacticalPanX = tacticalPanStartX - dx;
                tacticalPanY = tacticalPanStartY + dy; // Y is inverted
            }
        });
        
        tacticalCanvas.addEventListener('mouseup', () => {
            tacticalDragging = false;
            tacticalCanvas.style.cursor = 'grab';
        });
        
        tacticalCanvas.addEventListener('mouseleave', () => {
            tacticalDragging = false;
            tacticalCanvas.style.cursor = 'grab';
        });
        
        // Set initial cursor
        tacticalCanvas.style.cursor = 'grab';
        
        // Component colors
        const COLORS = {
            differential: '#c9a227',
            integrator: '#48bb78',
            resolver: '#4299e1',
            cam: '#ed8936',
            synchro: '#9f7aea',
            connection: '#4a5568',
            text: '#e2e8f0',
            gear: '#718096'
        };
        
        // Component definitions with positions
        const components = {
            // Position Keeper
            'So': { x: 50, y: 80, type: 'input', label: 'So', rotation: 0 },
            'Co': { x: 50, y: 160, type: 'input', label: 'Co', rotation: 0 },
            'B': { x: 50, y: 240, type: 'input', label: 'B', rotation: 0 },
            'S': { x: 50, y: 320, type: 'input', label: 'S', rotation: 0 },
            'C': { x: 50, y: 400, type: 'input', label: 'C', rotation: 0 },
            'R': { x: 50, y: 480, type: 'input', label: 'R', rotation: 0 },
            
            'diff_7': { x: 180, y: 200, type: 'differential', label: 'Diff 7\nBr=B-Co', rotation: 0 },
            'diff_33': { x: 180, y: 360, type: 'differential', label: 'Diff 33\nA', rotation: 0 },
            
            'resolver_13': { x: 320, y: 160, type: 'resolver', label: 'Res 13\nsin/cos Br', rotation: 0 },
            'resolver_34': { x: 320, y: 400, type: 'resolver', label: 'Res 34\nsin/cos A', rotation: 0 },
            
            'int_20': { x: 180, y: 80, type: 'integrator', label: 'Int 20\n‚à´So¬∑dT', rotation: 0, discRotation: 0 },
            'int_25': { x: 180, y: 440, type: 'integrator', label: 'Int 25\n‚à´S¬∑dT', rotation: 0, discRotation: 0 },
            
            'int_14': { x: 460, y: 120, type: 'integrator', label: 'Int 14\n‚à´So¬∑sinBr', rotation: 0, discRotation: 0 },
            'int_15': { x: 460, y: 200, type: 'integrator', label: 'Int 15\n‚à´So¬∑cosBr', rotation: 0, discRotation: 0 },
            'int_35': { x: 460, y: 360, type: 'integrator', label: 'Int 35\n‚à´S¬∑sinA', rotation: 0, discRotation: 0 },
            'int_36': { x: 460, y: 440, type: 'integrator', label: 'Int 36\n‚à´S¬∑cosA', rotation: 0, discRotation: 0 },
            
            'diff_28': { x: 600, y: 240, type: 'differential', label: 'Diff 28\nR¬∑dB', rotation: 0 },
            'diff_29': { x: 600, y: 320, type: 'differential', label: 'Diff 29\ndR', rotation: 0 },
            
            // Angle Solver
            'resolver_2FA': { x: 740, y: 160, type: 'resolver', label: 'Res 2FA\nG-Br', rotation: 0 },
            'cam_M': { x: 740, y: 280, type: 'cam', label: 'Cam M\nReach', rotation: 0 },
            'cam_J': { x: 740, y: 360, type: 'cam', label: 'Cam J\nTransfer', rotation: 0 },
            
            'diff_22FA': { x: 880, y: 220, type: 'differential', label: 'Diff 22FA\nGyro G', rotation: 0 },
            
            'G_out': { x: 1000, y: 220, type: 'output', label: 'GYRO\nANGLE', rotation: 0 }
        };
        
        // Connections between components
        const connections = [
            ['Co', 'diff_7'],
            ['B', 'diff_7'],
            ['diff_7', 'resolver_13'],
            ['C', 'diff_33'],
            ['B', 'diff_33'],
            ['diff_33', 'resolver_34'],
            ['So', 'int_20'],
            ['S', 'int_25'],
            ['resolver_13', 'int_14'],
            ['resolver_13', 'int_15'],
            ['int_20', 'int_14'],
            ['int_20', 'int_15'],
            ['resolver_34', 'int_35'],
            ['resolver_34', 'int_36'],
            ['int_25', 'int_35'],
            ['int_25', 'int_36'],
            ['int_14', 'diff_28'],
            ['int_35', 'diff_28'],
            ['int_15', 'diff_29'],
            ['int_36', 'diff_29'],
            ['diff_7', 'resolver_2FA'],
            ['diff_28', 'resolver_2FA'],
            ['diff_29', 'cam_M'],
            ['R', 'cam_J'],
            ['resolver_2FA', 'diff_22FA'],
            ['cam_M', 'diff_22FA'],
            ['diff_22FA', 'G_out']
        ];
        
        // Simulation state
        let isRunning = false;
        let simSpeed = 5.0;  // Default to max speed
        let time = 0;
        
        // Load Cobia image for tactical display
        const cobiaImg = new Image();
        cobiaImg.src = '/static/cobiatop.png';
        let cobiaImgLoaded = false;
        cobiaImg.onload = () => {
            cobiaImgLoaded = true;
        };
        
        // Torpedo state
        const TORPEDO_SPEED_KNOTS = 46;
        const TORPEDO_SPEED_YPS = TORPEDO_SPEED_KNOTS * 2025.4 / 3600; // ~25.9 yps
        const HIT_RADIUS = 30; // yards - how close torpedo needs to be to target
        
        // Torpedo trajectory parameters (from O.P. 1056) - must match TDC engine!
        const TUBE_BASE_LINE = 50;     // P - distance from conning tower to tubes (yards)
        const REACH_DISTANCE = 75;      // M - straight run before gyro engages (yards)
        const TORPEDO_TURN_RADIUS = 130; // Z - turning radius (yards)
        // Turn rate = speed / radius
        const TORPEDO_TURN_RATE_DPS = (TORPEDO_SPEED_YPS / TORPEDO_TURN_RADIUS) * (180 / Math.PI);
        
        let torpedoes = []; // Array of active torpedoes
        
        function fireTorpedo() {
            const gyroAngle = computed.gyroAngle;
            
            // Torpedo starts from bow (P yards ahead of conning tower/center)
            // TDC equations account for this via the Tube Base Line P
            const ownHeadingRad = inputs.ownCourse * Math.PI / 180;
            const startX = state.ownX + Math.sin(ownHeadingRad) * TUBE_BASE_LINE;
            const startY = state.ownY + Math.cos(ownHeadingRad) * TUBE_BASE_LINE;
            
            const torpedo = {
                x: startX,
                y: startY,
                heading: inputs.ownCourse, // Start heading along sub's course
                initialHeading: inputs.ownCourse,
                targetHeading: inputs.ownCourse + gyroAngle, // Final heading after turn
                gyroAngle: gyroAngle,
                trail: [{x: startX, y: startY}],
                active: true,
                result: null, // 'hit' or 'miss'
                distanceTraveled: 0,
                phase: 'initial', // 'initial', 'turning', 'final'
                turnProgress: 0, // degrees turned so far
                maxRange: computed.torpedoRun * 2.0 // Allow extra range before declaring miss
            };
            torpedoes.push(torpedo);
        }
        
        function updateTorpedoes(dt) {
            torpedoes.forEach(torpedo => {
                if (!torpedo.active) return;
                
                const headingRad = torpedo.heading * Math.PI / 180;
                let dx, dy, dist;
                
                // Phase-based movement
                if (torpedo.phase === 'initial') {
                    // Phase 1: Straight run along initial heading (sub's course)
                    dx = TORPEDO_SPEED_YPS * Math.sin(headingRad) * dt;
                    dy = TORPEDO_SPEED_YPS * Math.cos(headingRad) * dt;
                    torpedo.x += dx;
                    torpedo.y += dy;
                    dist = Math.sqrt(dx * dx + dy * dy);
                    torpedo.distanceTraveled += dist;
                    
                    // Check if reach (M) complete - gyro engages after M yards
                    if (torpedo.distanceTraveled >= REACH_DISTANCE) {
                        torpedo.phase = 'turning';
                        torpedo.turnProgress = 0;
                    }
                }
                else if (torpedo.phase === 'turning') {
                    // Phase 2: Circular arc turn to achieve gyro angle
                    const turnAmount = Math.abs(torpedo.gyroAngle);
                    
                    if (turnAmount < 0.5) {
                        // Negligible turn, skip to final
                        torpedo.phase = 'final';
                        torpedo.heading = torpedo.targetHeading;
                    } else {
                        // Turn at TORPEDO_TURN_RATE_DPS
                        const turnThisFrame = TORPEDO_TURN_RATE_DPS * dt;
                        const turnDirection = torpedo.gyroAngle > 0 ? 1 : -1; // positive = starboard
                        
                        torpedo.heading += turnDirection * turnThisFrame;
                        torpedo.turnProgress += turnThisFrame;
                        
                        // Move along the arc
                        const newHeadingRad = torpedo.heading * Math.PI / 180;
                        dx = TORPEDO_SPEED_YPS * Math.sin(newHeadingRad) * dt;
                        dy = TORPEDO_SPEED_YPS * Math.cos(newHeadingRad) * dt;
                        torpedo.x += dx;
                        torpedo.y += dy;
                        dist = Math.sqrt(dx * dx + dy * dy);
                        torpedo.distanceTraveled += dist;
                        
                        // Check if turn complete
                        if (torpedo.turnProgress >= turnAmount) {
                            torpedo.phase = 'final';
                            torpedo.heading = torpedo.targetHeading; // Snap to exact heading
                        }
                    }
                }
                else if (torpedo.phase === 'final') {
                    // Phase 3: Straight run on final heading
                    const finalHeadingRad = torpedo.heading * Math.PI / 180;
                    dx = TORPEDO_SPEED_YPS * Math.sin(finalHeadingRad) * dt;
                    dy = TORPEDO_SPEED_YPS * Math.cos(finalHeadingRad) * dt;
                    torpedo.x += dx;
                    torpedo.y += dy;
                    dist = Math.sqrt(dx * dx + dy * dy);
                    torpedo.distanceTraveled += dist;
                }
                
                // Record trail
                torpedo.trail.push({x: torpedo.x, y: torpedo.y});
                if (torpedo.trail.length > 500) torpedo.trail.shift();
                
                // Check for hit
                const distToTarget = Math.sqrt(
                    Math.pow(torpedo.x - state.targetX, 2) + 
                    Math.pow(torpedo.y - state.targetY, 2)
                );
                
                if (distToTarget < HIT_RADIUS) {
                    torpedo.active = false;
                    torpedo.result = 'hit';
                }
                // Check for miss (exceeded max range)
                else if (torpedo.distanceTraveled > torpedo.maxRange) {
                    torpedo.active = false;
                    torpedo.result = 'miss';
                }
            });
        }
        
        // Input values
        let inputs = {
            ownCourse: 281,
            ownSpeed: 3,
            targetBearing: 291,
            targetRange: 900,
            targetCourse: 115,
            targetSpeed: 8
        };
        
        // Position state (own ship at origin, target relative)
        // Units: yards, with Y = North, X = East
        let state = {
            ownX: 0,
            ownY: 0,
            targetX: 0,
            targetY: 0,
            elapsedTime: 0,
            // Trail history for visualization
            ownTrail: [],
            targetTrail: [],
            // Initial positions for fixed view center
            initialOwnX: 0,
            initialOwnY: 0,
            initialTargetX: 0,
            initialTargetY: 0
        };
        
        // Computed values
        let computed = {
            gyroAngle: 0,
            relBearing: 0,       // Br - relative bearing to target
            targetAngle: 0,      // A - target angle
            trackAngle: 0,
            torpedoRun: 0,
            runTime: 0,
            presentRange: 0,     // R - current range
            presentBearing: 0    // B - current true bearing
        };
        
        // TDC solving state - simulates the mechanical iteration
        let tdcState = {
            displayGyro: 0,      // The gyro angle currently shown (converging to actual)
            targetGyro: 0,       // The mathematically correct gyro angle
            isSolving: false,    // Whether actively converging
            solveRate: 15,       // Degrees per second base convergence rate (slower for drama)
            solved: false,       // Whether solution has been found
            solutionLocked: false, // Whether operator has "matched dials"
            huntAmplitude: 0,    // Oscillation amplitude during solving (simulates hunting)
            huntPhase: 0         // Phase of oscillation
        };
        
        const KNOTS_TO_YPS = 2025.4 / 3600; // yards per second per knot
        
        function initializeState() {
            // Initialize the TDC engine with current inputs
            tdc.setInputs({
                ownCourse: inputs.ownCourse,
                ownSpeed: inputs.ownSpeed,
                targetBearing: inputs.targetBearing,
                targetRange: inputs.targetRange,
                targetCourse: inputs.targetCourse,
                targetSpeed: inputs.targetSpeed
            });
            tdc.initialize();
            
            // Sync local state from engine
            state.ownX = tdc.state.ownX;
            state.ownY = tdc.state.ownY;
            state.targetX = tdc.state.targetX;
            state.targetY = tdc.state.targetY;
            state.elapsedTime = 0;
            
            // Store initial positions for fixed view center
            state.initialOwnX = state.ownX;
            state.initialOwnY = state.ownY;
            state.initialTargetX = state.targetX;
            state.initialTargetY = state.targetY;
            
            // Clear trails
            state.ownTrail = [{x: state.ownX, y: state.ownY}];
            state.targetTrail = [{x: state.targetX, y: state.targetY}];
        }
        
        function updatePositions(dt) {
            // Move own ship along its course
            const ownCourseRad = inputs.ownCourse * Math.PI / 180;
            const ownSpeedYps = inputs.ownSpeed * KNOTS_TO_YPS;
            state.ownX += ownSpeedYps * Math.sin(ownCourseRad) * dt;
            state.ownY += ownSpeedYps * Math.cos(ownCourseRad) * dt;
            
            // Move target along its course
            const targetCourseRad = inputs.targetCourse * Math.PI / 180;
            const targetSpeedYps = inputs.targetSpeed * KNOTS_TO_YPS;
            state.targetX += targetSpeedYps * Math.sin(targetCourseRad) * dt;
            state.targetY += targetSpeedYps * Math.cos(targetCourseRad) * dt;
            
            state.elapsedTime += dt;
            
            // Record trail positions (every 0.5 seconds of simulation time)
            const trailInterval = 0.5;
            if (state.ownTrail.length === 0 || 
                state.elapsedTime - (state.ownTrail.length - 1) * trailInterval >= trailInterval) {
                state.ownTrail.push({x: state.ownX, y: state.ownY});
                state.targetTrail.push({x: state.targetX, y: state.targetY});
                // Limit trail length
                if (state.ownTrail.length > 200) {
                    state.ownTrail.shift();
                    state.targetTrail.shift();
                }
            }
        }
        
        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width - 32;
            canvas.height = rect.height - 32;
            
            // Resize tactical canvas - fixed height
            const tacticalRect = tacticalCanvas.parentElement.getBoundingClientRect();
            tacticalCanvas.width = tacticalRect.width - 32;
            tacticalCanvas.height = 248; // Fixed height
        }
        
        function drawTactical() {
            const w = tacticalCanvas.width;
            const h = tacticalCanvas.height;
            const cx = w / 2;
            const cy = h / 2;
            
            // Clear
            tacticalCtx.fillStyle = '#050a14';
            tacticalCtx.fillRect(0, 0, w, h);
            
            // Draw grid
            tacticalCtx.strokeStyle = '#1a2a3a';
            tacticalCtx.lineWidth = 1;
            const gridSize = 40;
            for (let x = 0; x < w; x += gridSize) {
                tacticalCtx.beginPath();
                tacticalCtx.moveTo(x, 0);
                tacticalCtx.lineTo(x, h);
                tacticalCtx.stroke();
            }
            for (let y = 0; y < h; y += gridSize) {
                tacticalCtx.beginPath();
                tacticalCtx.moveTo(0, y);
                tacticalCtx.lineTo(w, y);
                tacticalCtx.stroke();
            }
            
            // Calculate scale: fit all positions (initial + current) in the view
            const allX = [state.ownX, state.targetX, state.initialOwnX, state.initialTargetX];
            const allY = [state.ownY, state.targetY, state.initialOwnY, state.initialTargetY];
            const minX = Math.min(...allX);
            const maxX = Math.max(...allX);
            const minY = Math.min(...allY);
            const maxY = Math.max(...allY);
            const rangeX = Math.max(maxX - minX, 200);
            const rangeY = Math.max(maxY - minY, 200);
            const maxRange = Math.max(rangeX, rangeY) * 1.3;
            const baseScale = Math.min(w, h) / maxRange * 0.8;
            const scale = baseScale * tacticalZoom;  // Apply zoom
            
            // Convert world coords (yards, Y=North, X=East) to screen coords
            // Center on initial midpoint plus any pan offset
            const viewCenterX = (state.initialOwnX + state.initialTargetX) / 2 + tacticalPanX;
            const viewCenterY = (state.initialOwnY + state.initialTargetY) / 2 + tacticalPanY;
            
            function toScreen(worldX, worldY) {
                return {
                    x: cx + (worldX - viewCenterX) * scale,
                    y: cy - (worldY - viewCenterY) * scale  // Y is flipped (screen Y down, world Y up/north)
                };
            }
            
            // --- Draw trails ---
            // Own ship trail
            if (state.ownTrail.length > 1) {
                tacticalCtx.strokeStyle = 'rgba(59, 130, 246, 0.5)';
                tacticalCtx.lineWidth = 2;
                tacticalCtx.beginPath();
                const firstOwn = toScreen(state.ownTrail[0].x, state.ownTrail[0].y);
                tacticalCtx.moveTo(firstOwn.x, firstOwn.y);
                for (let i = 1; i < state.ownTrail.length; i++) {
                    const pt = toScreen(state.ownTrail[i].x, state.ownTrail[i].y);
                    tacticalCtx.lineTo(pt.x, pt.y);
                }
                tacticalCtx.stroke();
            }
            
            // Target trail
            if (state.targetTrail.length > 1) {
                tacticalCtx.strokeStyle = 'rgba(239, 68, 68, 0.5)';
                tacticalCtx.lineWidth = 2;
                tacticalCtx.beginPath();
                const firstTarget = toScreen(state.targetTrail[0].x, state.targetTrail[0].y);
                tacticalCtx.moveTo(firstTarget.x, firstTarget.y);
                for (let i = 1; i < state.targetTrail.length; i++) {
                    const pt = toScreen(state.targetTrail[i].x, state.targetTrail[i].y);
                    tacticalCtx.lineTo(pt.x, pt.y);
                }
                tacticalCtx.stroke();
            }
            
            // Draw compass rose
            tacticalCtx.save();
            tacticalCtx.translate(w - 40, 40);
            tacticalCtx.strokeStyle = '#4a5568';
            tacticalCtx.lineWidth = 1;
            tacticalCtx.beginPath();
            tacticalCtx.arc(0, 0, 25, 0, Math.PI * 2);
            tacticalCtx.stroke();
            tacticalCtx.fillStyle = '#c9a227';
            tacticalCtx.font = '10px monospace';
            tacticalCtx.textAlign = 'center';
            tacticalCtx.fillText('N', 0, -30);
            tacticalCtx.beginPath();
            tacticalCtx.moveTo(0, -25);
            tacticalCtx.lineTo(0, -15);
            tacticalCtx.strokeStyle = '#c9a227';
            tacticalCtx.lineWidth = 2;
            tacticalCtx.stroke();
            tacticalCtx.restore();
            
            // Draw scale bar
            const scaleBarYards = Math.round(maxRange / 4 / 100) * 100;
            const scaleBarPx = scaleBarYards * scale;
            tacticalCtx.strokeStyle = '#4a5568';
            tacticalCtx.lineWidth = 2;
            tacticalCtx.beginPath();
            tacticalCtx.moveTo(20, h - 20);
            tacticalCtx.lineTo(20 + scaleBarPx, h - 20);
            tacticalCtx.stroke();
            tacticalCtx.fillStyle = '#a0aec0';
            tacticalCtx.font = '10px monospace';
            tacticalCtx.textAlign = 'left';
            tacticalCtx.fillText(scaleBarYards + ' yds', 20, h - 25);
            
            // --- Draw bearing line from own ship to target ---
            const ownScreen = toScreen(state.ownX, state.ownY);
            const targetScreen = toScreen(state.targetX, state.targetY);
            
            tacticalCtx.strokeStyle = '#48bb78';
            tacticalCtx.lineWidth = 1;
            tacticalCtx.setLineDash([5, 5]);
            tacticalCtx.beginPath();
            tacticalCtx.moveTo(ownScreen.x, ownScreen.y);
            tacticalCtx.lineTo(targetScreen.x, targetScreen.y);
            tacticalCtx.stroke();
            tacticalCtx.setLineDash([]);
            
            // --- Draw own ship heading line ---
            const headingLen = 80;
            const ownHeadingRad = inputs.ownCourse * Math.PI / 180;
            tacticalCtx.strokeStyle = '#3b82f6';
            tacticalCtx.lineWidth = 2;
            tacticalCtx.beginPath();
            tacticalCtx.moveTo(ownScreen.x, ownScreen.y);
            tacticalCtx.lineTo(
                ownScreen.x + Math.sin(ownHeadingRad) * headingLen,
                ownScreen.y - Math.cos(ownHeadingRad) * headingLen
            );
            tacticalCtx.stroke();
            // Arrow head
            tacticalCtx.save();
            tacticalCtx.translate(
                ownScreen.x + Math.sin(ownHeadingRad) * headingLen,
                ownScreen.y - Math.cos(ownHeadingRad) * headingLen
            );
            tacticalCtx.rotate(ownHeadingRad);
            tacticalCtx.beginPath();
            tacticalCtx.moveTo(0, 0);
            tacticalCtx.lineTo(-5, 10);
            tacticalCtx.lineTo(5, 10);
            tacticalCtx.closePath();
            tacticalCtx.fillStyle = '#3b82f6';
            tacticalCtx.fill();
            tacticalCtx.restore();
            
            // --- Draw target heading line ---
            const targetHeadingRad = inputs.targetCourse * Math.PI / 180;
            tacticalCtx.strokeStyle = '#ef4444';
            tacticalCtx.lineWidth = 2;
            tacticalCtx.beginPath();
            tacticalCtx.moveTo(targetScreen.x, targetScreen.y);
            tacticalCtx.lineTo(
                targetScreen.x + Math.sin(targetHeadingRad) * headingLen,
                targetScreen.y - Math.cos(targetHeadingRad) * headingLen
            );
            tacticalCtx.stroke();
            // Arrow head
            tacticalCtx.save();
            tacticalCtx.translate(
                targetScreen.x + Math.sin(targetHeadingRad) * headingLen,
                targetScreen.y - Math.cos(targetHeadingRad) * headingLen
            );
            tacticalCtx.rotate(targetHeadingRad);
            tacticalCtx.beginPath();
            tacticalCtx.moveTo(0, 0);
            tacticalCtx.lineTo(-5, 10);
            tacticalCtx.lineTo(5, 10);
            tacticalCtx.closePath();
            tacticalCtx.fillStyle = '#ef4444';
            tacticalCtx.fill();
            tacticalCtx.restore();
            
            // --- Draw torpedo solution path (reach + turn + final run) ---
            // Path starts from BOW (P yards ahead of center), same as actual torpedo
            const ownHeadingDeg = inputs.ownCourse;
            const ownHeadingRadTorp = ownHeadingDeg * Math.PI / 180;
            const torpedoHeading = inputs.ownCourse + computed.gyroAngle;
            const torpedoHeadingRad = torpedoHeading * Math.PI / 180;
            
            // Calculate bow position (P yards ahead of center)
            const bowOffsetX = Math.sin(ownHeadingRadTorp) * TUBE_BASE_LINE * scale;
            const bowOffsetY = -Math.cos(ownHeadingRadTorp) * TUBE_BASE_LINE * scale;
            const bowScreenX = ownScreen.x + bowOffsetX;
            const bowScreenY = ownScreen.y + bowOffsetY;
            
            tacticalCtx.strokeStyle = '#c9a227';
            tacticalCtx.lineWidth = 2;
            tacticalCtx.setLineDash([3, 3]);
            tacticalCtx.beginPath();
            tacticalCtx.moveTo(bowScreenX, bowScreenY);  // Start from bow
            
            // Phase 1: Reach M (straight run from bow before turn)
            const reachDist = REACH_DISTANCE * scale;
            const reachEndX = bowScreenX + Math.sin(ownHeadingRadTorp) * reachDist;
            const reachEndY = bowScreenY - Math.cos(ownHeadingRadTorp) * reachDist;
            tacticalCtx.lineTo(reachEndX, reachEndY);
            
            // Phase 2: Arc turn (approximate with line segments)
            const gyroAngleDeg = computed.gyroAngle;
            if (Math.abs(gyroAngleDeg) > 0.5) {
                const turnRadius = TORPEDO_TURN_RADIUS * scale;
                const turnDir = gyroAngleDeg > 0 ? 1 : -1;
                const steps = 12;
                const angleStep = gyroAngleDeg / steps;
                
                let currentAngle = ownHeadingDeg;
                let arcX = reachEndX;
                let arcY = reachEndY;
                
                // Calculate arc length per step
                const arcLengthPerStep = (Math.abs(gyroAngleDeg) * Math.PI / 180) * TORPEDO_TURN_RADIUS / steps * scale;
                
                for (let i = 0; i < steps; i++) {
                    currentAngle += angleStep;
                    const stepRad = currentAngle * Math.PI / 180;
                    arcX += Math.sin(stepRad) * arcLengthPerStep;
                    arcY -= Math.cos(stepRad) * arcLengthPerStep;
                    tacticalCtx.lineTo(arcX, arcY);
                }
                
                // Phase 3: Continue straight on final heading
                // torpedoRun is from submarine center, we started from bow, so subtract only M and arc
                const remainingDist = (computed.torpedoRun - REACH_DISTANCE - 
                    Math.abs(gyroAngleDeg) * Math.PI / 180 * TORPEDO_TURN_RADIUS) * scale;
                if (remainingDist > 0) {
                    tacticalCtx.lineTo(
                        arcX + Math.sin(torpedoHeadingRad) * remainingDist,
                        arcY - Math.cos(torpedoHeadingRad) * remainingDist
                    );
                }
            } else {
                // No significant turn, straight line
                const torpLineLen = computed.torpedoRun * scale;
                tacticalCtx.lineTo(
                    ownScreen.x + Math.sin(torpedoHeadingRad) * torpLineLen,
                    ownScreen.y - Math.cos(torpedoHeadingRad) * torpLineLen
                );
            }
            
            tacticalCtx.stroke();
            tacticalCtx.setLineDash([]);
            
            // --- Draw own ship (submarine icon) ---
            tacticalCtx.save();
            tacticalCtx.translate(ownScreen.x, ownScreen.y);
            tacticalCtx.rotate(ownHeadingRad);
            
            if (cobiaImgLoaded) {
                // Use Cobia image - scale with zoom level
                // Cobia was ~100 yards long, scale to world coordinates
                // Image is horizontal (bow pointing right), need to rotate -90¬∞ to point up
                tacticalCtx.rotate(-Math.PI / 2);
                const subLengthYards = 100;  // Gato-class ~311 feet ‚âà 100 yards
                const targetLength = subLengthYards * scale;  // Scale with zoom!
                const imgScale = targetLength / cobiaImg.width;
                const imgW = cobiaImg.width * imgScale;
                const imgH = cobiaImg.height * imgScale;
                tacticalCtx.drawImage(cobiaImg, -imgW/2, -imgH/2, imgW, imgH);
            } else {
                // Fallback: simple ellipse (scaled with zoom)
                const subLen = 100 * scale;  // 100 yards
                const subWid = 30 * scale;   // ~30 yards beam
                tacticalCtx.fillStyle = '#3b82f6';
                tacticalCtx.beginPath();
                tacticalCtx.ellipse(0, 0, subWid/2, subLen/2, 0, 0, Math.PI * 2);
                tacticalCtx.fill();
                tacticalCtx.strokeStyle = '#1e40af';
                tacticalCtx.lineWidth = 1;
                tacticalCtx.stroke();
            }
            tacticalCtx.restore();
            
            // --- Draw target ship (scaled with zoom) ---
            const targetLen = 150 * scale;  // ~150 yards for a cargo ship
            tacticalCtx.save();
            tacticalCtx.translate(targetScreen.x, targetScreen.y);
            tacticalCtx.rotate(targetHeadingRad);
            // Ship shape - triangle
            tacticalCtx.fillStyle = '#ef4444';
            tacticalCtx.beginPath();
            tacticalCtx.moveTo(0, -targetLen/2);           // Bow
            tacticalCtx.lineTo(targetLen/6, targetLen/3);  // Starboard
            tacticalCtx.lineTo(-targetLen/6, targetLen/3); // Port
            tacticalCtx.closePath();
            tacticalCtx.fill();
            tacticalCtx.strokeStyle = '#991b1b';
            tacticalCtx.lineWidth = Math.max(1, scale * 2);
            tacticalCtx.stroke();
            tacticalCtx.restore();
            
            // --- Draw torpedoes ---
            torpedoes.forEach((torpedo, idx) => {
                // Draw torpedo trail
                if (torpedo.trail.length > 1) {
                    tacticalCtx.strokeStyle = torpedo.result === 'hit' ? 'rgba(34, 197, 94, 0.7)' : 
                                              torpedo.result === 'miss' ? 'rgba(156, 163, 175, 0.5)' :
                                              'rgba(201, 162, 39, 0.7)';
                    tacticalCtx.lineWidth = 2;
                    tacticalCtx.beginPath();
                    const firstPt = toScreen(torpedo.trail[0].x, torpedo.trail[0].y);
                    tacticalCtx.moveTo(firstPt.x, firstPt.y);
                    for (let i = 1; i < torpedo.trail.length; i++) {
                        const pt = toScreen(torpedo.trail[i].x, torpedo.trail[i].y);
                        tacticalCtx.lineTo(pt.x, pt.y);
                    }
                    tacticalCtx.stroke();
                }
                
                // Draw torpedo
                const torpScreen = toScreen(torpedo.x, torpedo.y);
                tacticalCtx.save();
                tacticalCtx.translate(torpScreen.x, torpScreen.y);
                tacticalCtx.rotate(torpedo.heading * Math.PI / 180);
                
                // Torpedo shape
                if (torpedo.active) {
                    tacticalCtx.fillStyle = '#c9a227';
                } else if (torpedo.result === 'hit') {
                    tacticalCtx.fillStyle = '#22c55e';
                } else {
                    tacticalCtx.fillStyle = '#6b7280';
                }
                
                tacticalCtx.beginPath();
                tacticalCtx.ellipse(0, 0, 3, 8, 0, 0, Math.PI * 2);
                tacticalCtx.fill();
                // Nose
                tacticalCtx.beginPath();
                tacticalCtx.moveTo(-3, -8);
                tacticalCtx.lineTo(0, -12);
                tacticalCtx.lineTo(3, -8);
                tacticalCtx.closePath();
                tacticalCtx.fill();
                
                tacticalCtx.restore();
                
                // Draw hit/miss indicator
                if (torpedo.result === 'hit') {
                    tacticalCtx.fillStyle = '#22c55e';
                    tacticalCtx.font = 'bold 14px monospace';
                    tacticalCtx.textAlign = 'center';
                    tacticalCtx.fillText('üí• HIT!', torpScreen.x, torpScreen.y - 20);
                } else if (torpedo.result === 'miss') {
                    tacticalCtx.fillStyle = '#6b7280';
                    tacticalCtx.font = '10px monospace';
                    tacticalCtx.textAlign = 'center';
                    tacticalCtx.fillText('MISS', torpScreen.x, torpScreen.y - 15);
                }
            });
            
            // --- Labels ---
            tacticalCtx.font = 'bold 11px monospace';
            tacticalCtx.fillStyle = '#3b82f6';
            tacticalCtx.textAlign = 'left';
            tacticalCtx.fillText('COBIA', ownScreen.x + 15, ownScreen.y + 5);
            tacticalCtx.fillStyle = '#ef4444';
            tacticalCtx.fillText('TARGET', targetScreen.x + 15, targetScreen.y + 5);
            
            // --- Legend ---
            tacticalCtx.font = '9px monospace';
            tacticalCtx.textAlign = 'left';
            let legendY = 15;
            tacticalCtx.fillStyle = '#3b82f6';
            tacticalCtx.fillText('‚ñ¨ Own Course: ' + inputs.ownCourse + '¬∞', 10, legendY);
            legendY += 12;
            tacticalCtx.fillStyle = '#ef4444';
            tacticalCtx.fillText('‚ñ¨ Target Course: ' + inputs.targetCourse + '¬∞', 10, legendY);
            legendY += 12;
            tacticalCtx.fillStyle = '#48bb78';
            tacticalCtx.fillText('‚îà Bearing: ' + computed.presentBearing.toFixed(1) + '¬∞', 10, legendY);
            legendY += 12;
            tacticalCtx.fillStyle = '#c9a227';
            tacticalCtx.fillText('‚îà Torp Heading: ' + (inputs.ownCourse + computed.gyroAngle).toFixed(1) + '¬∞', 10, legendY);
        }
        
        function normalizeAngle(angle) {
            while (angle < -180) angle += 360;
            while (angle > 180) angle -= 360;
            return angle;
        }
        
        function computeTDC() {
            // Calculate current bearing and range from positions
            // Vector from own ship to target
            const dx = state.targetX - state.ownX;
            const dy = state.targetY - state.ownY;
            
            // Present range (R) - Position Keeper output
            computed.presentRange = Math.sqrt(dx * dx + dy * dy);
            
            // Present true bearing (B) - Position Keeper output
            computed.presentBearing = Math.atan2(dx, dy) * 180 / Math.PI;
            if (computed.presentBearing < 0) computed.presentBearing += 360;
            
            // Relative bearing (Br) = B - Co (Diff 7)
            computed.relBearing = normalizeAngle(computed.presentBearing - inputs.ownCourse);
            
            // Target angle (A) = B + 180 - C (Diff 33)
            computed.targetAngle = normalizeAngle(computed.presentBearing + 180 - inputs.targetCourse);
            
            // === Angle Solver: compute gyro angle for intercept ===
            const torpedoSpeed = 46; // knots
            const torpedoSpeedYps = torpedoSpeed * KNOTS_TO_YPS;
            const targetSpeedYps = inputs.targetSpeed * KNOTS_TO_YPS;
            
            // Estimate run time based on current range
            const estRunTime = computed.presentRange / torpedoSpeedYps;
            const targetAdvance = targetSpeedYps * estRunTime;
            
            // Future target position (relative to own ship's current position)
            const courseRad = inputs.targetCourse * Math.PI / 180;
            const futureX = dx + targetAdvance * Math.sin(courseRad);
            const futureY = dy + targetAdvance * Math.cos(courseRad);
            
            // Intercept bearing
            let interceptBearing = Math.atan2(futureX, futureY) * 180 / Math.PI;
            if (interceptBearing < 0) interceptBearing += 360;
            
            // Gyro angle = intercept bearing - own course
            // This is the "true" solution - store it as target for the solving animation
            tdcState.targetGyro = normalizeAngle(interceptBearing - inputs.ownCourse);
            
            // The displayed gyro angle converges toward the target (simulating mechanical solving)
            computed.gyroAngle = tdcState.displayGyro;
            
            // Track angle (use displayed gyro for consistency)
            const torpedoHeading = inputs.ownCourse + tdcState.displayGyro;
            computed.trackAngle = Math.abs(normalizeAngle(torpedoHeading - inputs.targetCourse + 180));
            if (computed.trackAngle > 180) computed.trackAngle = 360 - computed.trackAngle;
            
            // Torpedo run to intercept (use displayed gyro)
            const displayHeadingRad = (inputs.ownCourse + tdcState.displayGyro) * Math.PI / 180;
            // Recalculate intercept based on displayed gyro for consistency
            computed.torpedoRun = Math.sqrt(futureX * futureX + futureY * futureY);
            computed.runTime = computed.torpedoRun / torpedoSpeedYps;
        }
        
        function updateTDCSolving(dt) {
            // Simulate the mechanical Angle Solver converging to the solution
            // This mimics the hunting/damping behavior of real servo systems
            
            const error = tdcState.targetGyro - tdcState.displayGyro;
            
            // Normalize error to -180 to +180
            let normalizedError = error;
            while (normalizedError > 180) normalizedError -= 360;
            while (normalizedError < -180) normalizedError += 360;
            
            const errorMagnitude = Math.abs(normalizedError);
            
            // Update hunt oscillation (simulates servo hunting)
            tdcState.huntPhase += dt * 8; // Oscillation frequency
            
            if (errorMagnitude > 0.5) {
                // Still converging - add hunting oscillation that decreases as we get closer
                tdcState.huntAmplitude = Math.min(errorMagnitude * 0.15, 3);
                
                // Base convergence rate - slower when close (damped response)
                const convergenceRate = tdcState.solveRate * (0.3 + errorMagnitude / 50);
                
                // Move toward target with hunting oscillation
                const huntOffset = Math.sin(tdcState.huntPhase) * tdcState.huntAmplitude;
                const step = Math.sign(normalizedError) * Math.min(convergenceRate * dt, errorMagnitude * 0.8);
                
                tdcState.displayGyro += step;
                
                // Add hunt oscillation to displayed value (visual only, doesn't affect convergence)
                const displayWithHunt = tdcState.displayGyro + huntOffset;
                
                tdcState.displayGyro = normalizeAngle(tdcState.displayGyro);
                tdcState.isSolving = true;
                tdcState.solved = false;
            } else if (errorMagnitude > 0.1) {
                // Fine adjustment phase - minimal hunting
                tdcState.huntAmplitude *= 0.9; // Dampen hunt
                const step = Math.sign(normalizedError) * errorMagnitude * 0.5 * dt * 10;
                tdcState.displayGyro += step;
                tdcState.displayGyro = normalizeAngle(tdcState.displayGyro);
                tdcState.isSolving = true;
                tdcState.solved = false;
            } else {
                // Close enough - solution locked
                tdcState.displayGyro = tdcState.targetGyro;
                tdcState.huntAmplitude = 0;
                tdcState.isSolving = false;
                tdcState.solved = true;
            }
        }
        
        function updateOutputDisplay() {
            const gyroEl = document.getElementById('gyroAngle');
            
            // Show gyro angle with solving indicator
            if (tdcState.isSolving) {
                gyroEl.textContent = computed.gyroAngle.toFixed(1) + '¬∞ ‚ü≥';
                gyroEl.style.color = '#f59e0b'; // Amber while solving
            } else if (tdcState.solved) {
                gyroEl.textContent = computed.gyroAngle.toFixed(1) + '¬∞ ‚úì';
                gyroEl.style.color = '#22c55e'; // Green when solved
            } else {
                gyroEl.textContent = computed.gyroAngle.toFixed(1) + '¬∞';
                gyroEl.style.color = ''; // Default
            }
            
            document.getElementById('relBearing').textContent = computed.relBearing.toFixed(1) + '¬∞';
            document.getElementById('targetAngle').textContent = computed.targetAngle.toFixed(1) + '¬∞';
            document.getElementById('trackAngle').textContent = computed.trackAngle.toFixed(1) + '¬∞';
            document.getElementById('torpedoRun').textContent = computed.torpedoRun.toFixed(0) + ' yds';
            document.getElementById('runTime').textContent = computed.runTime.toFixed(1) + ' sec';
            
            // Also show present bearing and range (Position Keeper outputs)
            const bearingEl = document.getElementById('presentBearing');
            const rangeEl = document.getElementById('presentRange');
            const timeEl = document.getElementById('elapsedTime');
            if (bearingEl) bearingEl.textContent = computed.presentBearing.toFixed(1) + '¬∞';
            if (rangeEl) rangeEl.textContent = computed.presentRange.toFixed(0) + ' yds';
            if (timeEl) timeEl.textContent = state.elapsedTime.toFixed(1) + ' sec';
            
            // Update fire button state
            const fireBtn = document.getElementById('fireBtn');
            if (tdcState.solved) {
                fireBtn.disabled = false;
                fireBtn.textContent = 'üî• FIRE TORPEDO';
            } else {
                fireBtn.disabled = false; // Allow firing even while solving (for testing)
                fireBtn.textContent = tdcState.isSolving ? '‚ü≥ SOLVING...' : 'üî• FIRE TORPEDO';
            }
            
            // Update solution indicator light
            const light = document.getElementById('solutionLight');
            const label = document.getElementById('solutionLabel');
            
            if (tdcState.solved) {
                light.className = 'indicator-light solved';
                label.className = 'indicator-label solved';
                label.textContent = 'SOLUTION';
            } else if (tdcState.isSolving) {
                light.className = 'indicator-light solving';
                label.className = 'indicator-label solving';
                label.textContent = 'COMPUTING';
            } else {
                light.className = 'indicator-light';
                label.className = 'indicator-label';
                label.textContent = 'STANDBY';
            }
        }
        
        function drawGear(x, y, radius, teeth, rotation, color) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation * Math.PI / 180);
            
            ctx.beginPath();
            for (let i = 0; i < teeth; i++) {
                const angle = (i / teeth) * Math.PI * 2;
                const nextAngle = ((i + 0.5) / teeth) * Math.PI * 2;
                
                const innerR = radius * 0.85;
                const outerR = radius;
                
                ctx.lineTo(Math.cos(angle) * outerR, Math.sin(angle) * outerR);
                ctx.lineTo(Math.cos(nextAngle) * innerR, Math.sin(nextAngle) * innerR);
            }
            ctx.closePath();
            
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = '#1a1a2e';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // Center hub
            ctx.beginPath();
            ctx.arc(0, 0, radius * 0.3, 0, Math.PI * 2);
            ctx.fillStyle = '#1a1a2e';
            ctx.fill();
            ctx.strokeStyle = color;
            ctx.stroke();
            
            ctx.restore();
        }
        
        function drawDifferential(x, y, rotation, label) {
            // Draw three meshing bevel gears
            drawGear(x - 15, y, 20, 12, rotation, COLORS.differential);
            drawGear(x + 15, y, 20, 12, -rotation, COLORS.differential);
            drawGear(x, y, 15, 10, rotation * 0.5, COLORS.gear);
            
            // Label
            ctx.fillStyle = COLORS.text;
            ctx.font = '10px monospace';
            ctx.textAlign = 'center';
            const lines = label.split('\n');
            lines.forEach((line, i) => {
                ctx.fillText(line, x, y + 35 + i * 12);
            });
        }
        
        function drawIntegrator(x, y, discRotation, rollerPos, label) {
            // Draw disc
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(discRotation * Math.PI / 180);
            
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI * 2);
            ctx.fillStyle = COLORS.integrator;
            ctx.fill();
            ctx.strokeStyle = '#1a1a2e';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Radial lines on disc
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(angle) * 22, Math.sin(angle) * 22);
                ctx.strokeStyle = '#1a1a2e';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
            ctx.restore();
            
            // Draw roller
            const rollerX = x + rollerPos * 20;
            ctx.beginPath();
            ctx.arc(rollerX, y, 6, 0, Math.PI * 2);
            ctx.fillStyle = COLORS.gear;
            ctx.fill();
            
            // Label
            ctx.fillStyle = COLORS.text;
            ctx.font = '10px monospace';
            ctx.textAlign = 'center';
            const lines = label.split('\n');
            lines.forEach((line, i) => {
                ctx.fillText(line, x, y + 40 + i * 12);
            });
        }
        
        function drawResolver(x, y, rotation, label) {
            // Draw resolver as a circle with angle indicator
            ctx.beginPath();
            ctx.arc(x, y, 22, 0, Math.PI * 2);
            ctx.fillStyle = COLORS.resolver;
            ctx.fill();
            ctx.strokeStyle = '#1a1a2e';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Angle indicator
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation * Math.PI / 180);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, -18);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
            
            // Sin/Cos outputs
            ctx.beginPath();
            ctx.arc(x + 30, y - 8, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#48bb78';
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 30, y + 8, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#ed8936';
            ctx.fill();
            
            // Label
            ctx.fillStyle = COLORS.text;
            ctx.font = '10px monospace';
            ctx.textAlign = 'center';
            const lines = label.split('\n');
            lines.forEach((line, i) => {
                ctx.fillText(line, x, y + 35 + i * 12);
            });
        }
        
        function drawCam(x, y, rotation, label) {
            // Draw cam as eccentric circle
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation * Math.PI / 180);
            
            ctx.beginPath();
            ctx.ellipse(5, 0, 20, 15, 0, 0, Math.PI * 2);
            ctx.fillStyle = COLORS.cam;
            ctx.fill();
            ctx.strokeStyle = '#1a1a2e';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Center
            ctx.beginPath();
            ctx.arc(0, 0, 4, 0, Math.PI * 2);
            ctx.fillStyle = '#1a1a2e';
            ctx.fill();
            
            ctx.restore();
            
            // Label
            ctx.fillStyle = COLORS.text;
            ctx.font = '10px monospace';
            ctx.textAlign = 'center';
            const lines = label.split('\n');
            lines.forEach((line, i) => {
                ctx.fillText(line, x, y + 35 + i * 12);
            });
        }
        
        function drawInput(x, y, label) {
            ctx.beginPath();
            ctx.arc(x, y, 18, 0, Math.PI * 2);
            ctx.fillStyle = '#2d3748';
            ctx.fill();
            ctx.strokeStyle = COLORS.brass;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = COLORS.brass;
            ctx.font = 'bold 12px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, x, y);
        }
        
        function drawOutput(x, y, label, value) {
            ctx.beginPath();
            ctx.roundRect(x - 35, y - 25, 70, 50, 8);
            ctx.fillStyle = '#1a1a2e';
            ctx.fill();
            ctx.strokeStyle = COLORS.brass;
            ctx.lineWidth = 3;
            ctx.stroke();
            
            ctx.fillStyle = COLORS.brass;
            ctx.font = 'bold 10px monospace';
            ctx.textAlign = 'center';
            const lines = label.split('\n');
            lines.forEach((line, i) => {
                ctx.fillText(line, x, y - 8 + i * 14);
            });
            
            ctx.fillStyle = '#48bb78';
            ctx.font = 'bold 14px monospace';
            ctx.fillText(value.toFixed(1) + '¬∞', x, y + 18);
        }
        
        function drawConnection(from, to) {
            const c1 = components[from];
            const c2 = components[to];
            if (!c1 || !c2) return;
            
            ctx.beginPath();
            ctx.moveTo(c1.x + 25, c1.y);
            ctx.lineTo(c2.x - 25, c2.y);
            ctx.strokeStyle = COLORS.connection;
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Scale to fit canvas - design is for 1050px wide, 550px tall
            const designWidth = 1050;
            const designHeight = 550;
            const scaleX = canvas.width / designWidth;
            const scaleY = canvas.height / designHeight;
            const scale = Math.min(scaleX, scaleY, 1.0); // Don't scale up beyond 1x
            
            ctx.save();
            ctx.scale(scale, scale);
            
            // Draw connections first
            connections.forEach(([from, to]) => {
                drawConnection(from, to);
            });
            
            // Draw components
            for (const [id, comp] of Object.entries(components)) {
                switch (comp.type) {
                    case 'differential':
                        drawDifferential(comp.x, comp.y, comp.rotation, comp.label);
                        break;
                    case 'integrator':
                        drawIntegrator(comp.x, comp.y, comp.discRotation || 0, 
                                      Math.sin(time * 2) * 0.5, comp.label);
                        break;
                    case 'resolver':
                        drawResolver(comp.x, comp.y, comp.rotation, comp.label);
                        break;
                    case 'cam':
                        drawCam(comp.x, comp.y, comp.rotation, comp.label);
                        break;
                    case 'input':
                        drawInput(comp.x, comp.y, comp.label);
                        break;
                    case 'output':
                        drawOutput(comp.x, comp.y, comp.label, computed.gyroAngle);
                        break;
                }
            }
            
            // Title
            ctx.fillStyle = COLORS.text;
            ctx.font = '12px monospace';
            ctx.textAlign = 'left';
            ctx.fillText('POSITION KEEPER', 150, 30);
            ctx.fillText('ANGLE SOLVER', 700, 30);
            
            // Dividing line
            ctx.beginPath();
            ctx.moveTo(660, 50);
            ctx.lineTo(660, designHeight - 20);
            ctx.strokeStyle = COLORS.steel;
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.restore();
        }
        
        // Track previous values to calculate rates of change
        let prevComputed = {
            relBearing: 0,
            targetAngle: 0,
            presentBearing: 0,
            gyroAngle: 0
        };
        
        // Accumulated values for integrators (representing ‚à´ over time)
        let integrated = {
            ownDistance: 0,      // ‚à´So¬∑dT - own ship travel
            targetDistance: 0,  // ‚à´S¬∑dT - target travel
            dB_sin: 0,          // ‚à´So¬∑sin(Br)¬∑dT
            dB_cos: 0,          // ‚à´So¬∑cos(Br)¬∑dT
            dA_sin: 0,          // ‚à´S¬∑sin(A)¬∑dT
            dA_cos: 0           // ‚à´S¬∑cos(A)¬∑dT
        };
        
        function updateAnimation(dt) {
            const scaledDt = dt * simSpeed;
            time += scaledDt;
            
            // === RUN THE TDC ENGINE ===
            // This is where the mechanical computer actually does its work
            // The solution emerges from the component interactions
            
            // Sync inputs to engine
            tdc.setInputs({
                ownCourse: inputs.ownCourse,
                ownSpeed: inputs.ownSpeed,
                targetBearing: inputs.targetBearing,
                targetRange: inputs.targetRange,
                targetCourse: inputs.targetCourse,
                targetSpeed: inputs.targetSpeed
            });
            
            // Step the mechanical simulation
            tdc.step(scaledDt);
            
            // Update torpedoes (separate from TDC)
            updateTorpedoes(scaledDt);
            
            // === SYNC ENGINE STATE TO LOCAL VARIABLES ===
            // These are now computed by the mechanism, not formulas
            
            // Position state from engine
            state.ownX = tdc.state.ownX;
            state.ownY = tdc.state.ownY;
            state.targetX = tdc.state.targetX;
            state.targetY = tdc.state.targetY;
            state.elapsedTime = tdc.state.elapsedTime;
            
            // Record trail for tactical display
            if (state.ownTrail.length === 0 || 
                state.elapsedTime - (state.ownTrail.length - 1) * 0.5 >= 0.5) {
                state.ownTrail.push({x: state.ownX, y: state.ownY});
                state.targetTrail.push({x: state.targetX, y: state.targetY});
                if (state.ownTrail.length > 200) {
                    state.ownTrail.shift();
                    state.targetTrail.shift();
                }
            }
            
            // Computed values from engine (emerged from mechanism!)
            computed.gyroAngle = tdc.outputs.gyroAngle;
            computed.relBearing = tdc.outputs.relativeBearing;
            computed.targetAngle = tdc.outputs.targetAngle;
            computed.trackAngle = tdc.outputs.trackAngle;
            computed.torpedoRun = tdc.outputs.torpedoRun;
            computed.runTime = tdc.outputs.runTime;
            computed.presentRange = tdc.outputs.presentRange;
            computed.presentBearing = tdc.outputs.presentBearing;
            
            // Solving state from engine
            tdcState.isSolving = !tdc.outputs.isSolved;
            tdcState.solved = tdc.outputs.isSolved;
            tdcState.displayGyro = tdc.outputs.gyroAngle;
            tdcState.targetGyro = tdc.outputs.gyroAngle; // Same since engine computes it
            
            updateOutputDisplay();
            
            // === VISUAL COMPONENT ANIMATION ===
            // Now driven by ACTUAL component states from the engine!
            
            // Get component states from engine
            const engineComponents = tdc.components;
            
            // --- RESOLVERS: Show actual computed angles ---
            components['resolver_13'].rotation = engineComponents.resolver_13.rotation;
            components['resolver_34'].rotation = engineComponents.resolver_34.rotation;
            components['resolver_2FA'].rotation = engineComponents.resolver_2FA.rotation;
            
            // --- DIFFERENTIALS: Show actual rotation from computation ---
            components['diff_7'].rotation = engineComponents.diff_7.rotation;
            components['diff_33'].rotation = engineComponents.diff_33.rotation;
            components['diff_28'].rotation = engineComponents.diff_28.rotation;
            components['diff_29'].rotation = engineComponents.diff_29.rotation;
            components['diff_22FA'].rotation = engineComponents.diff_22FA.rotation;
            
            // --- INTEGRATORS: Show disc rotation from integration ---
            components['int_20'].discRotation = engineComponents.int_20.discRotation;
            components['int_25'].discRotation = engineComponents.int_25.discRotation;
            components['int_14'].discRotation = engineComponents.int_14.discRotation;
            components['int_15'].discRotation = engineComponents.int_15.discRotation;
            components['int_35'].discRotation = engineComponents.int_35.discRotation || 0;
            components['int_36'].discRotation = engineComponents.int_36.discRotation || 0;
            
            // --- CAMS: Show actual position from engine ---
            components['cam_M'].rotation = engineComponents.cam_P.rotation;
            components['cam_J'].rotation = engineComponents.cam_J.rotation;
        }
        
        let lastTime = 0;
        function animate(currentTime) {
            const dt = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            if (dt < 0.1) {
                if (isRunning) {
                    // Full simulation - ships move and TDC computes
                    updateAnimation(dt);
                } else {
                    // Paused - only update geometry display, don't run angle solver
                    // TDC will start hunting when Start is pressed
                    updateGeometryOnly();
                }
            }
            
            draw();
            drawTactical();
            requestAnimationFrame(animate);
        }
        
        function updateGeometryOnly() {
            // Update geometry display without running angle solver
            // Called when paused - TDC won't hunt until Start is pressed
            
            // Guard: make sure engine components exist
            if (!tdc.components || !tdc.components.resolver_13) {
                return;
            }
            
            // Sync inputs to engine
            tdc.setInputs({
                ownCourse: inputs.ownCourse,
                ownSpeed: inputs.ownSpeed,
                targetBearing: inputs.targetBearing,
                targetRange: inputs.targetRange,
                targetCourse: inputs.targetCourse,
                targetSpeed: inputs.targetSpeed
            });
            
            // Calculate geometry from positions
            tdc.calculatePresentGeometry();
            
            // Run position keeper for relative bearing and target angle display
            tdc.runPositionKeeper(0); // dt=0 since ships aren't moving
            
            // Update geometry outputs only (not gyro - that waits for Start)
            computed.relBearing = tdc.outputs.relativeBearing;
            computed.targetAngle = tdc.outputs.targetAngle;
            computed.presentRange = tdc.outputs.presentRange;
            computed.presentBearing = tdc.outputs.presentBearing;
            
            // TDC is not solving yet
            tdcState.isSolving = false;
            tdcState.solved = false;
            
            // Show gyro at current position (starts at 0)
            computed.gyroAngle = tdc.gyroAngle;
            tdcState.displayGyro = tdc.gyroAngle;
            
            // Update resolver rotations for static display
            const engineComponents = tdc.components;
            if (engineComponents.resolver_13) components['resolver_13'].rotation = engineComponents.resolver_13.rotation;
            if (engineComponents.resolver_34) components['resolver_34'].rotation = engineComponents.resolver_34.rotation;
            
            updateOutputDisplay();
        }
        
        function runTDCWithSolver(dt) {
            // Run full TDC including angle solver - called when simulation is running
            
            // Guard: make sure engine components exist
            if (!tdc.components || !tdc.components.resolver_13) {
                return;
            }
            
            // Sync inputs to engine
            tdc.setInputs({
                ownCourse: inputs.ownCourse,
                ownSpeed: inputs.ownSpeed,
                targetBearing: inputs.targetBearing,
                targetRange: inputs.targetRange,
                targetCourse: inputs.targetCourse,
                targetSpeed: inputs.targetSpeed
            });
            
            // Need to calculate present geometry first (uses initial positions)
            tdc.calculatePresentGeometry();
            
            // Run position keeper for relative bearing and target angle
            tdc.runPositionKeeper(dt);
            
            // Run angle solver - this is where the hunting happens
            tdc.runAngleSolver(dt);
            
            // Get outputs
            computed.gyroAngle = tdc.outputs.gyroAngle;
            computed.trackAngle = tdc.outputs.trackAngle;
            computed.relBearing = tdc.outputs.relativeBearing;
            computed.targetAngle = tdc.outputs.targetAngle;
            computed.presentRange = tdc.outputs.presentRange;
            computed.presentBearing = tdc.outputs.presentBearing;
            tdcState.isSolving = !tdc.outputs.isSolved;
            tdcState.solved = tdc.outputs.isSolved;
            tdcState.displayGyro = tdc.outputs.gyroAngle;
            
            // Update component animations
            const engineComponents = tdc.components;
            
            // Resolvers
            if (engineComponents.resolver_13) components['resolver_13'].rotation = engineComponents.resolver_13.rotation;
            if (engineComponents.resolver_34) components['resolver_34'].rotation = engineComponents.resolver_34.rotation;
            if (engineComponents.resolver_2FA) components['resolver_2FA'].rotation = engineComponents.resolver_2FA.rotation;
            
            // Differentials
            if (engineComponents.diff_7) components['diff_7'].rotation = engineComponents.diff_7.rotation;
            if (engineComponents.diff_33) components['diff_33'].rotation = engineComponents.diff_33.rotation;
            if (engineComponents.diff_22FA) components['diff_22FA'].rotation = engineComponents.diff_22FA.rotation;
            
            // Cams (cam_M in visualizer corresponds to cam_P in engine)
            if (engineComponents.cam_P) components['cam_M'].rotation = engineComponents.cam_P.rotation;
            if (engineComponents.cam_J) components['cam_J'].rotation = engineComponents.cam_J.rotation;
            
            updateOutputDisplay();
        }
        
        // Event listeners
        document.getElementById('startBtn').addEventListener('click', () => {
            isRunning = !isRunning;
            document.getElementById('startBtn').textContent = isRunning ? '‚è∏ PAUSE' : '‚ñ∂ START';
        });
        
        document.getElementById('fireBtn').addEventListener('click', () => {
            // Start simulation if not running
            if (!isRunning) {
                isRunning = true;
                document.getElementById('startBtn').textContent = '‚è∏ PAUSE';
            }
            fireTorpedo();
        });
        
        document.getElementById('randomBtn').addEventListener('click', () => {
            // Stop simulation
            isRunning = false;
            time = 0;
            document.getElementById('startBtn').textContent = '‚ñ∂ START';
            
            // Generate random tactical scenario with realistic attack geometry
            
            // Own course: any direction (set first, as target bearing depends on it)
            inputs.ownCourse = Math.floor(Math.random() * 360);
            
            // Own speed: 2-8 knots (typical approach speeds)
            inputs.ownSpeed = Math.floor(Math.random() * 7) + 2;
            
            // Target bearing: must be in FORWARD arc (within ¬±90¬∞ of own course)
            // This ensures target is ahead, not behind the submarine
            const bearingOffset = Math.floor(Math.random() * 181) - 90; // -90 to +90
            inputs.targetBearing = (inputs.ownCourse + bearingOffset + 360) % 360;
            
            // Target range: 800-3000 yards (typical attack ranges within Mark 14 torpedo range)
            inputs.targetRange = Math.floor(Math.random() * 2200) + 800;
            
            // Target speed: 6-14 knots (typical merchant/warship speeds)
            inputs.targetSpeed = Math.floor(Math.random() * 9) + 6;
            
            // Target course: constrained so Angle on Bow ‚â§ 90¬∞ either side
            // AoB = angle between target heading and bearing TO submarine
            // For AoB ‚â§ 90¬∞, target course should be within ¬±90¬∞ of (bearing + 180)
            // This ensures the target is presenting a beam shot or approaching, not running away
            const reciprocalBearing = (inputs.targetBearing + 180) % 360;
            const aobOffset = Math.floor(Math.random() * 181) - 90; // -90 to +90
            inputs.targetCourse = (reciprocalBearing + aobOffset + 360) % 360;
            
            // Update input fields
            document.getElementById('ownCourse').value = inputs.ownCourse;
            document.getElementById('ownSpeed').value = inputs.ownSpeed;
            document.getElementById('targetBearing').value = inputs.targetBearing;
            document.getElementById('targetRange').value = inputs.targetRange;
            document.getElementById('targetCourse').value = inputs.targetCourse;
            document.getElementById('targetSpeed').value = inputs.targetSpeed;
            
            // Clear torpedoes
            torpedoes = [];
            
            // Reset tactical map zoom/pan
            tacticalZoom = 1.0;
            tacticalPanX = 0;
            tacticalPanY = 0;
            
            // Reset TDC solving state - gyro starts at 0, not solved
            tdcState.displayGyro = 0;
            tdcState.targetGyro = 0;
            tdcState.isSolving = false;
            tdcState.solved = false;
            computed.gyroAngle = 0;
            
            // Reset the TDC engine's gyro angle to 0
            tdc.gyroAngle = 0;
            tdc.servoVelocity = 0;
            tdc.outputs.gyroAngle = 0;
            tdc.outputs.isSolved = false;
            
            // Reset integrated values
            integrated.ownDistance = 0;
            integrated.targetDistance = 0;
            integrated.dB_sin = 0;
            integrated.dB_cos = 0;
            integrated.dA_sin = 0;
            integrated.dA_cos = 0;
            
            // Reset component rotations
            for (const comp of Object.values(components)) {
                comp.rotation = 0;
                if (comp.discRotation !== undefined) comp.discRotation = 0;
            }
            
            // Initialize ship positions with new scenario
            initializeState();
            
            // Compute geometry only (not gyro angle - that waits for Start)
            const dx = state.targetX - state.ownX;
            const dy = state.targetY - state.ownY;
            computed.presentRange = Math.sqrt(dx * dx + dy * dy);
            computed.presentBearing = Math.atan2(dx, dy) * 180 / Math.PI;
            if (computed.presentBearing < 0) computed.presentBearing += 360;
            computed.relBearing = normalizeAngle(computed.presentBearing - inputs.ownCourse);
            computed.targetAngle = normalizeAngle(computed.presentBearing + 180 - inputs.targetCourse);
            
            // Reset previous computed values
            prevComputed.relBearing = computed.relBearing;
            prevComputed.targetAngle = computed.targetAngle;
            prevComputed.presentBearing = computed.presentBearing;
            prevComputed.gyroAngle = 0;
            
            updateOutputDisplay();
        });
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            isRunning = false;
            time = 0;
            document.getElementById('startBtn').textContent = '‚ñ∂ START';
            
            // Clear torpedoes
            torpedoes = [];
            
            // Reset TDC solving state - gyro starts at 0, not solved
            tdcState.displayGyro = 0;
            tdcState.targetGyro = 0;
            tdcState.isSolving = false;
            tdcState.solved = false;
            computed.gyroAngle = 0;
            
            // Reset the TDC engine's gyro angle to 0
            tdc.gyroAngle = 0;
            tdc.servoVelocity = 0;
            tdc.outputs.gyroAngle = 0;
            tdc.outputs.isSolved = false;
            
            // Reset positions to initial state
            initializeState();
            
            // Compute geometry only (not gyro angle - that waits for Start)
            const dx = state.targetX - state.ownX;
            const dy = state.targetY - state.ownY;
            computed.presentRange = Math.sqrt(dx * dx + dy * dy);
            computed.presentBearing = Math.atan2(dx, dy) * 180 / Math.PI;
            if (computed.presentBearing < 0) computed.presentBearing += 360;
            computed.relBearing = normalizeAngle(computed.presentBearing - inputs.ownCourse);
            computed.targetAngle = normalizeAngle(computed.presentBearing + 180 - inputs.targetCourse);
            
            updateOutputDisplay();
            
            // Reset integrated values
            integrated.ownDistance = 0;
            integrated.targetDistance = 0;
            integrated.dB_sin = 0;
            integrated.dB_cos = 0;
            integrated.dA_sin = 0;
            integrated.dA_cos = 0;
            
            // Reset previous computed values
            prevComputed.relBearing = computed.relBearing;
            prevComputed.targetAngle = computed.targetAngle;
            prevComputed.presentBearing = computed.presentBearing;
            prevComputed.gyroAngle = computed.gyroAngle;
            
            // Reset component rotations
            for (const comp of Object.values(components)) {
                comp.rotation = 0;
                if (comp.discRotation !== undefined) comp.discRotation = 0;
            }
        });
        
        document.getElementById('simSpeed').addEventListener('input', (e) => {
            simSpeed = parseFloat(e.target.value);
            document.getElementById('speedLabel').textContent = simSpeed.toFixed(1) + 'x';
        });
        
        // Input change handlers
        ['ownCourse', 'ownSpeed', 'targetBearing', 'targetRange', 'targetCourse', 'targetSpeed'].forEach(id => {
            document.getElementById(id).addEventListener('input', (e) => {
                inputs[id] = parseFloat(e.target.value) || 0;
                // Re-initialize positions when bearing or range changes (defines initial geometry)
                if (id === 'targetBearing' || id === 'targetRange') {
                    initializeState();
                    // Reset gyro - it will need to find solution again when started
                    tdc.gyroAngle = 0;
                    tdc.servoVelocity = 0;
                    computed.gyroAngle = 0;
                    tdcState.solved = false;
                }
                // Update geometry display only (gyro waits for Start)
                const dx = state.targetX - state.ownX;
                const dy = state.targetY - state.ownY;
                computed.presentRange = Math.sqrt(dx * dx + dy * dy);
                computed.presentBearing = Math.atan2(dx, dy) * 180 / Math.PI;
                if (computed.presentBearing < 0) computed.presentBearing += 360;
                computed.relBearing = normalizeAngle(computed.presentBearing - inputs.ownCourse);
                computed.targetAngle = normalizeAngle(computed.presentBearing + 180 - inputs.targetCourse);
                updateOutputDisplay();
            });
        });
        
        // Initialize
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        initializeState();
        
        // Initial geometry display (gyro starts at 0, waits for Start to begin hunting)
        const dx = state.targetX - state.ownX;
        const dy = state.targetY - state.ownY;
        computed.presentRange = Math.sqrt(dx * dx + dy * dy);
        computed.presentBearing = Math.atan2(dx, dy) * 180 / Math.PI;
        if (computed.presentBearing < 0) computed.presentBearing += 360;
        computed.relBearing = normalizeAngle(computed.presentBearing - inputs.ownCourse);
        computed.targetAngle = normalizeAngle(computed.presentBearing + 180 - inputs.targetCourse);
        computed.gyroAngle = 0;
        
        updateOutputDisplay();
        requestAnimationFrame(animate);
    </script>
</body>
</html>

